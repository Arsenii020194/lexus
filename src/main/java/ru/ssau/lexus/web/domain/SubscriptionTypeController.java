/*
 * Source code generated by Celerio, a Jaxio product.
 * Documentation: http://www.jaxio.com/documentation/celerio/
 * Follow us on twitter: @jaxiosoft
 * Need commercial support ? Contact us: info@jaxio.com
 * Template pack-custom:src/main/java/controller/Controller.e.vm.java
 */
package ru.ssau.lexus.web.domain;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import ru.ssau.lexus.domain.dto.SubscriptionTypeDto;
import ru.ssau.lexus.service.SubscriptionTypeService;

import javax.validation.Valid;
import java.net.URISyntaxException;

import java.util.Optional;
import lombok.AllArgsConstructor;
import java.util.Collection;

@RestController
@AllArgsConstructor
public class SubscriptionTypeController {

    protected final SubscriptionTypeService subscriptionTypeService;

    /**
     * {@code POST  /subscription-type} : Create a new subscriptionType.
     *
     * @param subscriptionTypeDto the subscriptionTypeDto to create.
     * @return the {@link ResponseEntity} with status {@code 201 (Created)} and with body the new subscriptionTypeDto, or with status {@code 400 (Bad Request)} if the subscriptionType has already an ID.
     * @throws URISyntaxException if the Location URI syntax is incorrect.
     */

    @PostMapping("/subscription-type/create")
    public ResponseEntity<SubscriptionTypeDto> createSubscriptionType(@Valid @RequestBody SubscriptionTypeDto subscriptionTypeDto) throws Exception {
        if (subscriptionTypeDto.getId() != null) {
            throw new Exception("A new subscriptionType cannot already have an ID");
        }
        SubscriptionTypeDto result = subscriptionTypeService.save(subscriptionTypeDto);
        return ResponseEntity.ok().body(result);
    }

    /**
     * {@code PUT  /subscription-type} : Updates an existing anodeHist.
     *
     * @param subscriptionTypeDto the subscriptionTypeDto to update.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the updated subscriptionTypeDto,
     * or with status {@code 400 (Bad Request)} if the subscriptionTypeDto is not valid,
     * or with status {@code 500 (Internal Server Error)} if the subscriptionTypeDto couldn't be updated.
     * @throws URISyntaxException if the Location URI syntax is incorrect.
     */
    @PutMapping("/subscription-type/update")
    public ResponseEntity<SubscriptionTypeDto> updateSubscriptionType(@Valid @RequestBody SubscriptionTypeDto subscriptionTypeDto) throws Exception {
        if (subscriptionTypeDto.getId() == null) {
            throw new Exception("Invalid id");
        }
        SubscriptionTypeDto result = subscriptionTypeService.save(subscriptionTypeDto);
        return ResponseEntity.ok().body(result);
    }

    /**
     * {@code GET  /subscription-type} : get all the subscriptionTypes.
     *
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and the list of subscriptionTypes in body.
     */
    @GetMapping("/subscription-type")
    public ResponseEntity<Collection<SubscriptionTypeDto>> getAllSubscriptionTypes() {
        return ResponseEntity.ok().body(subscriptionTypeService.findAll());
    }

    /**
     * {@code GET  /subscription-type/:id} : get the "id" subscriptionType.
     *
     * @param id the id of the subscriptionTypeDTO to retrieve.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the subscriptionTypeDto, or with status {@code 404 (Not Found)}.
     */
    @GetMapping("/subscription-type/{id}")
    public ResponseEntity<SubscriptionTypeDto> getSubscriptionType(@PathVariable Long id) {
        Optional<SubscriptionTypeDto> subscriptionTypeDto = subscriptionTypeService.findOne(id);

        return subscriptionTypeDto.map(dto -> ResponseEntity.ok().body(dto)).orElseGet(() -> ResponseEntity.status(HttpStatus.NOT_FOUND).body(null));

    }

    /**
     * {@code DELETE  /subscription-type/:id} : delete the "id" subscriptionType.
     *
     * @param id the id of the subscriptionTypeDto to delete.
     * @return the {@link ResponseEntity} with status {@code 204 (NO_CONTENT)}.
     */
    @DeleteMapping("/subscription-type/delete/{id}")
    public ResponseEntity<Void> deleteSubscriptionType(@PathVariable Long id) {
        subscriptionTypeService.delete(id);

        return ResponseEntity.ok().build();
    }
}